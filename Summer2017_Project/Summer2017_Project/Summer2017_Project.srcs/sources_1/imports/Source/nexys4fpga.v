/////////////////////////////////////////////////////////////////////////////////////////////////////////
// nexys4fpga.v
// Author  : Thanh Tien Truong
// Date    : September 16, 2017
// Version : 1
// 
// Description:
// ------------	
// This is the top module of the design. The module is responsible for driving
// internal Verilog signals to the physical pins on the Nexys4 DDR3 FPGA board.
// The module also contains other instance to communicate with on-board PDM mirophone
// PS2 Keyboard and OV7670 VGA Camera.
//
// Note:
// -------------
// This current design is to make sure that the Nexys4 DDR3 FPGA board can communicate
// with the PDM microphone, the PS2 keyboard and the OV7670 VGA Camera and can retrieve
// valid data from them. In order words, this design is for validating data purpose.
// Therefore, multiple modules will be removed in the final version of the design.
//
///////////////////////////////////////////////////////////////////////////////////////////////////////
`timescale 1ns / 1ps

module nexys4fpga(
    // System Clock - 100MHZ
    input               clk,
    //output  [7:0]       JD,
    //output  [7:0]       JC,
    
    // Pushbuttons and Switches
    input               btnC,
    input               btnL,
    input               btnR,
    input               btnU,
    input               btnD,
    input               btnCpuReset,
    input       [15:0]  sw,          
    
    // Signals for LEDs, and 7-segments
    output      [15:0]  led,        
    output      [6:0]   seg,        
    output              dp,
    output      [7:0]   an,             
    
    // RGB LEDs
    output              RGB1_Blue,
    output              RGB1_Green,
    output              RGB1_Red,
    output              RGB2_Blue,
    output              RGB2_Green,
    output              RGB2_Red,
    
    // PS2 - keyboard
    input               PS2_CLK,
    input               PS2_DATA,
    
    // PDM microphone
    output              M_CLK,      
    input               M_DATA,    
    output              M_LRSEL,    
      
    // PWM audio
    output              AUD_PWM,   
    output              AUD_SD,
    
    // OV7670 connections
    output          OV7670_SIOC,            // OV7670 SCCB interface - clock signal
    inout           OV7670_SIOD,            // OV7670 SCCB interface - data signal
    input           OV7670_VSYNC,           // OV7670 VSYNC         signal
    input           OV7670_HREF,            // OV7670 HREF          signal
    input           OV7670_PCLK,            // OV7670 Pixcel clock  signal  
    output          OV7670_XCLK,            // OV7670 System clock  signal
    input   [7:0]   OV7670_D,               // OV7670 8-bit data    signal

    // VGA connections          
    output  [3:0]   vga_red,                   
    output  [3:0]   vga_green, 
    output  [3:0]   vga_blue, 
    output          vga_hsync, 
    output          vga_vsync
);

    wire FACE_DETECT;
    
//////////////////////////////////////////////////////////////////////////////////////
// global internal variables
/////////////////////////////////////////////////////////////////////////////////////
    wire sysclk, sysreset;          // System clock and active-low reset
    wire rst;                       // Active high reset
   
    wire [5:0]		db_btns;        // Pushbuttons generated by debounce module
    wire [15:0]     db_sw;          // Switches generated by debounce module

//////////////////////////////////////////////////////////////////////////////////////
// Internal variables for keyboard part
/////////////////////////////////////////////////////////////////////////////////////
    
    // Memory
    wire [11:0] Addr_W;                 // Address location when write into memory
    wire [7:0] character;               // Ascii value for a scan code (data to write into memory) 
    reg  [11:0] Addr_R = 12'b0;         // Address location when read from memory
    wire [7:0] data_out;                // Data read from memory 
    
    // Control signals
    wire caps_lock;                     // Flag indicate capslock key is pressed
    wire delete;                        // Flag indicate backspace key is pressed
    wire compare;                       // Flag indicate enter key is pressed
    
    // Output from keyboard
    wire [7:0] keyboard;                // Scan code from a keyboard  
    
    // These 3 variables below is for keyboard demo, so they will be gone latter
    reg [23:0] data_buffer = 24'b0;     // Holding 3 Ascii values
    reg [11:0] curr_addr = 12'b0;       // Latching the current pointer to the memory 
    reg [1:0]  counter = 2'b0;          // Holding the current number of Ascii values
    
    // RGB values for RGB LEDS
    reg        int_RGB_Red1 = 1'b0, int_RGB_Green1 = 1'b0, int_RGB_Blue1 = 1'b0;
    reg        int_RGB_Red2 = 1'b0, int_RGB_Green2 = 1'b0, int_RGB_Blue2 = 1'b0;

//////////////////////////////////////////////////////////////////////////////////////
// Internal variables for microphone part
/////////////////////////////////////////////////////////////////////////////////////
    
    wire        mic_en;
    
//////////////////////////////////////////////////////////////////////////////////////
// Internal variables for OV7670 camera
//////////////////////////////////////////////////////////////////////////////////////
    
    wire        clk50;                                 // 50Mhz clock signal
    wire        clk25;                                 // 25Mhz clock signal   
    wire        resend;                                // Signal to re-configure OV7670

    // RAM interface
    wire [17:0] frame_addr;                     // address to read from memory
    wire [15:0] frame_pixel;                    // data from reading a memory location
    wire [17:0] capture_addr;                   // address to write to memory
    wire [15:0] capture_data;                   // data to write into a memory location
    wire        capture_we;                            // Write enable signal to RAM
   
    wire [11:0] new_frame_pixel;
    wire [9:0]  pixel_x;
    wire [9:0]  pixel_y;
   
//////////////////////////////////////////////////////////////////////////////////////
// Internal variables for 7-segment LEDs
/////////////////////////////////////////////////////////////////////////////////////
    
    wire [63:0] digits_out;
    
    // Signals for each 7-segment display
    wire 	[4:0]		dig7, dig6,
						dig5, dig4,
						dig3, dig2, 
						dig1, dig0;				
	wire 	[7:0]		decpts;					// decimal points
	wire    [7:0]       segs_int;               // sevensegment module the segments and the decimal point


//////////////////////////////////////////////////////////////////////////////////////
// Signal assigments
/////////////////////////////////////////////////////////////////////////////////////

    // global assigns
    assign sysclk = clk;                        // Create a global clock signal
    assign sysreset = db_btns[0];               // Create a global active-low reset
    assign rst = ~db_btns[0];                   // Create a glabal active-high reset
    
    assign dp = segs_int[7];
    assign seg = segs_int[6:0];
    
    //set up the display and LEDs   
	assign	dig7 = {3'b0,counter};              // Indicate current number of ascii in the buffer					
	assign	dig6 = {4'b0,caps_lock};            // 0 --> Caps is off, 1 --> Caps is on ?
	assign	dig5 = {1'b0,data_buffer[23:20]};   // 4 MSB of the 1st ascii value in the buffer
	assign	dig4 = {1'b0,data_buffer[19:16]};   // 4 LSB of the 1st ascii value in the buffer 
	assign	dig3 = {1'b0,data_buffer[15:12]};   // 4 MSB of the 2nd ascii value in the buffer
	assign	dig2 = {1'b0,data_buffer[11:8]};    // 4 LSB of the 2nd ascii value in the buffer 
	assign 	dig1 = {1'b0,data_buffer[7:4]};     // 4 MSB of the 3rd ascii value in the buffer
	assign	dig0 = {1'b0,data_buffer[3:0]};     // 4 LSB of the 3rd ascii value in the buffer
	 
	assign	decpts = 8'b01010100;			    // Decimal points on 7-seg LEDs
	
	
	assign	led = db_sw;        // leds show the debounced switches

    // Enable microphone for microphone demo
    assign  mic_en = db_btns[5];
    
    // Camerea
    assign OV7670_XCLK = clk25;             // Assign system clock for OV7670 (25Mhz according to OV7670 datasheet)
    assign resend = ~db_btns[0];            // Assign reset signal

//////////////////////////////////////////////////////////////////////////////////////
// Instantiations - for demo and debugging only
// - Creating an instance to control 8 7-segment LEDs and LEDs array
// - Creating an instance to generate debouce signals for pushbutton and switches 
/////////////////////////////////////////////////////////////////////////////////////

    // instantiate the 7-segment, 8-digit display
    sevensegment
    #(
        .RESET_POLARITY_LOW(1)
    ) SSB
    (
        // inputs for control signals
        .d0(dig0),
        .d1(dig1),
        .d2(dig2),
        .d3(dig3),
        .d4(dig4),
        .d5(dig5),
        .d6(dig6),
        .d7(dig7),
        .dp(decpts),
            
        // outputs to seven segment display
        .seg(segs_int),            
        .an(an),
            
        // clock and reset signals (100 MHz clock, active high reset)
        .clk(sysclk),
        .reset(sysreset),
            
        // ouput for simulation only
        .digits_out(digits_out)
    );

    // instantiate debounce
	debounce
	#(
		// Reset signal is active low
		.RESET_POLARITY_LOW(1)
	) DB
	(
		.clk(sysclk),	                                      // I - 100 Mhz clock signal
		.pbtn_in({btnC,btnL,btnU,btnR,btnD,btnCpuReset}),     // I - 6 Pushbuttons
		.switch_in(sw),                                       // I - 16 Switches
		.pbtn_db(db_btns),                                    // O - debounce signal for pushbuttons
		.swtch_db(db_sw)                                      // O - debounce signal for switches
	);
	
//////////////////////////////////////////////////////////////////////////////////////
// KEYBOARD DEMO
// -------------
// The demo let the user enter 3 keys from the keyboard, save their ASCII values into 
// a buffer then compare pre-defined buffer with that 3 ascii values. 7-segment LEDs
// will be used to display ascii values while RGB LEDs will be used to indicate if
// the 3 pressed keys are the 3 correct ones.
//
// Notes:
// ------
// Besdie a buffer to hold 3 ascii values, there is an instance of the dual port
// memory. The demo doesn't use the dual port memory since the demo is only for proving
// that the FPGA can succesfully receive a scan code and use it.
// 
// The demo inlcude:
// -----------------
// - An instance to get the scan code
// - An instance to convert scan code to ASCII
// - Section of code to save the ascii into the buffer, check the control signals
//   and generate color for RGB LEDs
//
/////////////////////////////////////////////////////////////////////////////////////
    wire [7:0] data_out_example;
    
	//Generate 50 MHz clock signal for keyboard
    reg  clk_50MHZ = 0;
    always @(posedge sysclk) begin
        clk_50MHZ <= ~clk_50MHZ;
    end
    
    // An instance to get the scan code
    keyboard keyboard_inst (
        .clk(clk_50MHZ),                    // I - Keyboard works best with 50MHZ
        .reset(rst),                        // I - Active high reset      
        .kclk (PS2_CLK),                    // I - PS2 clock
        .kdata (PS2_DATA),                  // I - PS2 data
        .CAPS_ON(caps_lock),                // O - Flag indicate capslock is pressed or not       
        .Address(Addr_W),                   // O - 12-bit data of a memory location
        .key_press(keyboard)                // O - 8-bit Scan Code of the pressed key
    );              
           
    // An instance to convert scan code to ASCII
    Converter Converter_inst (
        .clk(sysclk),                       // I - Clock signal
        .CapsLk(caps_lock),                 // I - FlagFlag indicate capslock is pressed or not 
        .data(keyboard),                    // I - 8-bit Scan Code received from keyboard module
        .keypress(character)                // O - 8-bit ASCII
    );
    
    // An instance for dual ports memory
    Buffer_Generator buffer_inst (
        .clk(sysclk),                       // I - 100 Mhz clock signal       
        .Addr_Write(Addr_W),                // I - 12-bit data for writing location
        .Data_Write(character),             // I - 8-bit data for writing value

        .Addr_Read(12'b0),                  // I - 12-bit data for reading location
        .Data_Read(data_out_example)        // O - 8-bit data for reading value
    );
    
    PWM_RGB RGB_Red1    (.clk(sysclk), .d_in(int_RGB_Red1),   .pwm(RGB1_Red));
    PWM_RGB RGB_Green1  (.clk(sysclk), .d_in(int_RGB_Green1), .pwm(RGB1_Green));
    PWM_RGB RGB_Blue1   (.clk(sysclk), .d_in(int_RGB_Blue1),  .pwm(RGB1_Blue));
    
    PWM_RGB RGB_Red2    (.clk(sysclk), .d_in(int_RGB_Red2),   .pwm(RGB2_Red));
    PWM_RGB RGB_Green2  (.clk(sysclk), .d_in(int_RGB_Green2), .pwm(RGB2_Green));
    PWM_RGB RGB_Blue2   (.clk(sysclk), .d_in(int_RGB_Blue2),  .pwm(RGB2_Blue));
    
    //////////////////////////////////////////////
    // Main section of the keyboard demo
    //////////////////////////////////////////////
    always @ (posedge sysclk or posedge rst) begin
        if (rst) begin
            data_buffer <= 24'b0;
            counter <= 2'd0;
            int_RGB_Blue1 <= 1'b0;
            int_RGB_Green1 <= 1'b0;
            int_RGB_Red1 <= 1'b0;
            int_RGB_Blue2 <= 1'b0;
            int_RGB_Green2 <= 1'b0;
            int_RGB_Red2 <= 1'b0;  
            curr_addr <= 12'b0;
        end
        else begin
            curr_addr <= Addr_W;                // Latch the previous address
            if (curr_addr != Addr_W) begin      // If current address is different from previous address --> there is new data
                if (keyboard == 8'h5A) begin    // If user press Enter key
                    // Compare three ascii values in the buffer with the three pre-defined ascii values
                    // RGB LEDs will be red if there is a difference
                    // RGB LEDs will be green if all three are match 
                    if (data_buffer[23:16] == 8'h61 && data_buffer[15:8] == 8'h62 && data_buffer[7:0] == 8'h63) begin
                        int_RGB_Blue1 <= 1'b0;
                        int_RGB_Green1 <= 1'b1;
                        int_RGB_Red1 <= 1'b0;
                        int_RGB_Blue2 <= 1'b0;
                        int_RGB_Green2 <= 1'b1;
                        int_RGB_Red2 <= 1'b0;   
                    end
                    else begin
                        int_RGB_Blue1 <= 1'b0;
                        int_RGB_Green1 <= 1'b0;
                        int_RGB_Red1 <= 1'b1;
                        int_RGB_Blue2 <= 1'b0;
                        int_RGB_Green2 <= 1'b0;
                        int_RGB_Red2 <= 1'b1;  
                    end
                    
                    // Reset the buffer for new inputs
                    counter <= 2'd0;
                    data_buffer <= 24'b0;
                end
                else if (keyboard == 8'h66) begin   // If user press Backspace key
                    case (counter)                  // Check current number of ascii values in the buffer
                        12'd1: data_buffer[23:16] <= 8'h00; 
                        12'd2: data_buffer[15:8] <= 8'h00; 
                        12'd3: data_buffer[7:0] <= 8'h00;
                        default: data_buffer <= data_buffer;
                    endcase
                    
                    // Update the current number of ascii values
                    if (counter == 2'd1 || counter == 2'd0) counter <= 2'd0;
                    else                 counter <= counter - 1'b1; 
                end
                else if (keyboard != 8'h00 && keyboard != 8'h58) begin  // If user press a normal key (not Enter, not Backspace, not Caps)
                    case (counter)                                      // Check current number of ascii values in the buffer
                        12'd0: data_buffer[23:16] <= character; 
                        12'd1: data_buffer[15:8] <= character; 
                        12'd2: data_buffer[7:0] <= character;
                        default: data_buffer <= data_buffer;
                    endcase
                    
                    // Update the current number of ascii values
                    if (counter == 2'd3) counter <= 2'd3;
                    else                 counter <= counter + 1'b1; 
                end
            end 
        end
    end
 /////////////////////////////////// END KEYBOARD DEMO ////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////////
// MICROPHONE DEMO
// ---------------
// The demo lets users heard the sound recorded by the microphone through the on-board
// audio port. The microphone will not be activate until the center button is pressed.
// After a center button is pressed, there are 10 seconds that users can use the microphone
// to record voice.
//
// Note:
// -----
// The PWM audio is only used for this demo section to test the quality of the recorded voice.
// The final version of the design might not include the PWM audio
//////////////////////////////////////////////////////////////////////////////////////////////


    // Create an instance for microphone and audio port
	Audio_Generator Audio_gen (
		// Common signals
		.clk_100Mhz(sysclk),			// input 100 Mhz buffered clock					
        .reset(rst),							// input Reset signal for the microphone and audio ports
		.btn_u(mic_en),						// input Pushbuttons Up										--> from on-board pushbutton

		// Signals for microphone
		.pdm_clk(M_CLK),						// output clock signal from Nexys4 to microphone
		.pdm_data(M_DATA),						// input data from microphone to Nexys4
		.pdm_lrsel(M_LRSEL),					// input - Set to '0', therefore data is read on the positive edge
		
		// Signals for audio ports
		.pwm_audio(AUD_PWM),					// Output Audio data to the lowpass filters
		.pwm_sdaudio(AUD_SD)					// Output Audio enable	
   );


////////////////////////////////// END MICROPHONE DEMO //////////////////////////////
 
 
//////////////////////////////////////////////////////////////////////////////////////
// OV7670 CAMERA DEMO
// ------------------
// The demo let users see the quality of the frames captured by the camera through a
// VGA screen. The demo also shows "Skin Detection" feature which seperate pixels that
// have "skin color" with pixels that don't have "skin color". Switch 15th will be used
// to activate or de-activate "Skin Detection" feature.
//
// Note:
// -----
// The "Skin Detection" feature is just our practice in the image processing field.
// The final design might not includes this feature.
/////////////////////////////////////////////////////////////////////////////////////

   // Create two instance of a clock divider to generate 50Mhz and 25Mhz clock signals
    Clock_Divider clock_divider_1(
        .clk_in(sysclk),               // 1-bit Input  100Mhz clock
        .clk_out(clk50)             // 1-bit Output 50Mhz  clock --> to debounce, frame buffer and OV7670 controller
    );
        
    Clock_Divider clock_divider_2(
        .clk_in(clk50),             // 1-bit Input  50Mhz clock
        .clk_out(clk25)             // 1-bit Output 25Mhz clock --> to VGA
    );
    
    // Create an instance for SCCB interface and configure OV7670
    OV7670_Controller Camera_Controller(
        .clk(clk50),                        // 1-bit Input 50Mhz clock
        .resend(resend),                    // 1-bit Reset signal to re-configure OV7670
        .config_finished(config_finished),  // 1-bit Flag indicating the current state of OV7670
        .sioc(OV7670_SIOC),                 // 1-bit Output to OV7670 --> SCCB serial interface clock
        .siod(OV7670_SIOD)                    // 1-bit Output to OV7670 --> SCCB serial interface data I/O
    );
    
    // Create an instance to read data from OV7670
    OV7670_Frame_Collector Frame_Collector(
        .pclk(OV7670_PCLK),                 // 1-bit  Input Pixel Clock from OV7670
        .vsync(OV7670_VSYNC),               // 1-bit  Input VSYNC signal from OV7670
        .href(OV7670_HREF),                 // 1-bit  Input HREF signal from OV7670
        .d(OV7670_D),                       // 8-bit  Input data from OV7670
        .addr(capture_addr),                // 18-bit Output to Frame Buffer --> Memory location to write
        .dout(capture_data),                // 12-bit Output to Frame Buffer --> Data to write 
        .we(capture_we)                     // 1-bit  Output to Frame Buffer --> Write enable signal to Frame Buffer 
    );

    Frame_Buffer Frame_Buffer_inst (
        .clka(OV7670_PCLK),    // input wire clka
        .wea(capture_we),      // input wire [0 : 0] wea
        .addra(capture_addr),  // input wire [17 : 0] addra
        .dina(capture_data),    // input wire [15 : 0] dina
        .clkb(clk25),         // input wire clkb
        .addrb(frame_addr),  // input wire [17 : 0] addrb
        .doutb(frame_pixel)  // output wire [15 : 0] doutb
    );
  
    // filter the color to get the skin location
    Color_Filter Filter(
        .clk(clk50),
        .reset(rst),
        .pixel_x(pixel_x),
        .pixel_y(pixel_y),
        .enable_skin_detection(db_sw[15]),
        .enable_spatial_filter(1'b0),
        .raw_pixel_color(frame_pixel),
        .new_pixel_color(new_frame_pixel),        
        .face_detect(FACE_DETECT)
    );
         
    // Create an instance to controll VGA
    VGA_Controller VGA(
        .clk25(clk25),                      // 1-bit  Input 25Mhz clock
        .vga_red(vga_red),                  // 3-bit  Output to VGA red
        .vga_green(vga_green),              // 3-bit  Output to VGA green
        .vga_blue(vga_blue),                // 3-bit  Output to VGA blue
        .vga_hsync(vga_hsync),              // 1-bit  Output to VGA hsync
        .vga_vsync(vga_vsync),              // 1-bit  Output to VGA vsync
        .frame_addr(frame_addr),            // 18-bit Output frame address  --> to frame buffer
        //.frame_pixel(frame_pixel),
        .frame_pixel(new_frame_pixel),      // 12-bit Input frame pixel     --> from frame buffer
        .pixel_x(pixel_x),
        .pixel_y(pixel_y)
    );

endmodule

